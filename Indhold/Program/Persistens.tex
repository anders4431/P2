I vores program har vi brug for, at kunne gemme data et sted så dataene kan hentes ind igen, når programmet starter. Dette kaldes persistens og kan opnås på flere forskellige måder, og vi har undersøgt nogle få nærmere.
De data vi gerne vil gemme til næste gang, programmet starter, er blandt andet oplysninger om, hvilke brugere der er i systemet, hvilke pligter der eksisterer og informationer om overførsler til de forskellige konti. 

Til at løse denne opgave, har vi kigget på følgende oplagte muligheder.

\subsubsection{XML fil}
XML er et simpelt format, til at gemme information, der er let læseligt for både mennesker og computere. Informationerne der skal gemmes, struktureres med tags, og gemmes i en fil på harddisken\cite{xmlspecs}. Tekstfilen kan så åbnes med en teksteditor, og der kan nemt ændres i, og tilføjes data til filen.

%evt eksempel på noget xml værk?

\subsubsection{Relationel database}
En relationel database er god til at håndtere en stor mængde data med samme struktur. Data bliver delt op i tabeller med præcist definerede kolonner, og databasen selv understøtter en masse forskellige operationer (sorter efter, større end m.fl.), og kriterier for udvælgelse af hvilke data rækker der skal returneres. Af relationelle databaser kiggede vi specifikt på SQLite, som er et lille bibliotek, der kan integreres direkte i programmet. Modsat dette findes dedikerede database systemer som MySQL og PostgreSQL, der kører som separate programmer. Til at tilgå og manipulere data i en relationel database bruges sproget SQL.

Her ligger det store arbejde i koblingen mellem objekter i vores program og rækker i databasen. Alle variable i en klasse skal mappes over til kolonner i databasen og specielt referencer til andre objekter og egne datatyper, kan være svære at håndtere. Denne problemstilling kendes som "The object-relational impedance mismatch"\cite{ORIM}.

\subsubsection{Objekt database}
En objektdatabase er forskellig fra en relationel database, på den måde, at den er baseret på objekter og derfor bare kan tage mod et objekt og gemme det, uden at der først er defineret hvordan elementer i objektet mapper til felter i databasen.
\\

Vi har i udviklingsforløbet valgt at bruge en object database af flere årsager. For det første er den er enkel at implementere. For det andet, vil slippe for, at skulle lave en "mapping" mellem klasser i C\# og kolonner i den relationelle database, hvor med en relationel database, vil "mappingen" mellem klasser og kolonner skulle opdateres eller omskrives hver gang en klasse ændres. Dette vil specielt være omfattende for os, da vi med vores begrænsede erfaring i objekt orienteret programmering, ofte vil lave store ændringer af vores klasser.
Til at klare opgaven som objekt database benyttes databasen NDatabase. NDatabase er en simpel open source objekt database lavet til C\#. Databasen understøtter LINQ, der er query sprog i Microsoft .NET Framework, der understøtter typesikkerhed og IntelliSense\cite{linqdok}.

Til at håndtere forbindelsen til objekt databasen, er der lavet en statisk klasse. For at gemme fx et objekt af typen \code{Transfer} i databasen, benytter vi \code{Store} metoden beskrevet i listing \ref{lst:db} . For så at hente transfers ud igen, benyttes metoden \code{GetTransfersForChild}, der ved brug af en LINQ-forespørgelsel returnerer overførslerne hørende til et objekt af typen \code{Child}. Denne database forbindelse behøver stort set ingen opdateringer, selvom vi skulle lave store ændringer i klasserne.
Desværre oplevede vi, at efterhånden som vi fik lagt flere brugere, pligter og overførsler i databasen, blev den meget langsom. Derfor valgte vi til sidst, at skifte til at bruge den relationelle SQLite.


I SQLite databasen, har vi lavet fire tabeller. De er designet til at gemme objekter af typerne \code{Transfers}, \code{Chores}, \code{Users} og \code{Childs}. Hver tabel indeholder så definerede felter/kolonner med et navn og en datatype. Disse navne og datatyper er for hver tabel beskrevet i tabel \ref{tab:sql1} og \ref{tab:sql2}. 
I listing \ref{lst:sqlite} beskrives hvordan vi forbinder til sqlite bla bla bla..

\newcommand{\cent}[1]{\hspace*{\fill}#1\hspace*{\fill}}
 
\begin{table}[htb]
	\small 
	\newcolumntype{C}{>{\centering}X}
	\setlength{\tabcolsep}{1pt}
	
	\begin{tabularx}{\textwidth}{||c|C||c|X||}
		\hline 
		\multicolumn{2}{||c||}{Transfers} & \multicolumn{2}{c||}{Chores}\\
		\hline
		ID & Int (Primary, Increment) & ID & \cent{Int (Primary, Increment)} \\ 
		\hline 
		Title & Text & Title & \cent{Text} \\ 
		\hline 
		Amount & Real & Amount & \cent{Real} \\ 
		\hline 
		Description & Text & Description & \cent{Text} \\ 
		\hline 
		ReCipient & Int (Foreign) & Deadline & \cent{Int} \\ 
		\hline 
		Date & Int & State & \cent{Int} \\ 
		\hline 
		Sender & Int (Foreign) & Assigned Child & \cent{Int (Foreign)} \\ 
		\hline 
		Type & Int & Type & \cent{Int} \\ 
		\hline 
	\end{tabularx}
	
	\caption{Transfer- \& Chores-tabeller}
	\label{TransferChoresTabeller}
\end{table}

\begin{table}[htb]
	\small 
	\newcolumntype{C}{>{\centering}X}
	\setlength{\tabcolsep}{1pt}
	
	\begin{tabularx}{\textwidth}{||c|C||c|X||}
		\hline 
		\multicolumn{2}{||c||}{Users} & \multicolumn{2}{c||}{Childs}\\
		\hline
		ID & Int (Primary, Increment) & ID & \cent{Int (Primary, Increment)} \\ 
		\hline 
		First name & Text & First name & \cent{Text} \\ 
		\hline 
		Last name & Text & Last name & \cent{Text} \\ 
		\hline 
		Password & Text & Password & \cent{Text} \\ 
		\hline 
		IsAdmin & Int & IsAdmin & \cent{Int} \\ 
		\hline 
		- & - & Amount & \cent{Real} \\ 
		\hline 
	\end{tabularx}
	
	\caption{Users- \& Childs-tabeller}
	\label{UsersChildssTabeller}
\end{table}

\begin{lstlisting}[caption={Statisk klasse, der forbinder til objekt databasen NDatabase},label={lst:db}]
>>>>>>> a3bc11d472c8f56ad18f08cf31e3e7254c614162
public static class db
{
	//En string dbFileName med filnavnet på databasen laves
	private const string dbFileName = "database.db";
	
	//Herefter åbnes database forbindelsen
	private static NDatabase.Api.IOdb odb = OdbFactory.Open(dbFileName);

	public static void Store(Transfer transfer)
	{
		//Objektet bliver sendt til databasen
		odb.Store(transfer);
		
		//Databasen bliver tvunget til at opdatere
		odb.Commit();
	}
	
	public static Collection<Transfer> GetTransfersForChild(Child child)
	{
		var transfers = from transfer in odb.QueryAndExecute<Transfer>()
						where transfer.Recipient != null && transfer.Recipient.FullName == child.FullName
						select transfer;

		Collection<Transfer> Transfers = new Collection<Transfer>();

		foreach (var t in transfers)
			Transfers.Add(t);

		return Transfers;
	}
}
\end{lstlisting}

<<<<<<< HEAD
\begin{lstlisting}[caption={Uddrag af filen "db.cs" fra kildekoden til programmet},label={lst:sqlite}]
    public static class db
    {
        private const string dbFileName = "test.sqlite";
        private static SQLiteConnection conn;

        public static void OpenDB()
        {
            conn = new SQLiteConnection("Data Source=" + dbFileName + ";Version=3;");
            conn.Open();
        }

        public static void CloseDB()
        {
            conn.Close();
        }


        public static void Store(Transfer transfer)
        {
            int ChildIDInDB = GetIDOfChild(transfer.Recipient);
            string ChildID = ((ChildIDInDB == 0) ? "null" : ChildIDInDB.ToString());

            string query = "INSERT INTO Transfers (Title, Description, Amount, Recipient, Date, Type, Sender) VALUES ('" +
                            transfer.Title + "', '" +
                            transfer.Description + "', '" +
                            transfer.Amount.ToString(CultureInfo.GetCultureInfo("en-GB")) + "', '" +
                            ChildID + "', '" +
                            SQLiteConvert.ToUnixEpoch((DateTime)transfer.TransferDate) + "', '" +
                            //DateTimeToUnixTimeStamp((DateTime)transfer.TransferDate) + "', '" +
                            (int)transfer.Type + "', '" +
                            "null" + "')"; //GetIDOfUser(transfer.Sender) + "', '" +   //TODO: implement

            SQLiteCommand command = new SQLiteCommand(query, conn);
            command.ExecuteNonQuery();
        }


        public static Collection<Transfer> GetTransfersForChild(Child child)
        {
            string query = "SELECT * FROM Transfers WHERE " +
                            "Recipient IN (SELECT ID FROM Childs WHERE " +
                                            "FirstName='" + child.FirstName + "'" +
                                            ")";

            SQLiteCommand command = new SQLiteCommand(query, conn);
            SQLiteDataReader r = command.ExecuteReader();

            Collection<Transfer> TransferList = new Collection<Transfer>();

            while (r.Read())
            {
                int ID = r.GetInt32(r.GetOrdinal("ID"));
                string Title = r.GetString(r.GetOrdinal("Title"));
                string Description = r.GetString(r.GetOrdinal("Description"));
                decimal Amount = r.GetDecimal(r.GetOrdinal("Amount"));
                Child Recipient = child;
                DateTime Date = SQLiteConvert.ToDateTime(((long)r["Date"]).ToString(), SQLiteDateFormats.UnixEpoch, DateTimeKind.Local);
                ActivityType Type = (ActivityType)(long)r["Type"];
                User Sender = null; //TODO: implement   ((int)r["Sender"] == null) ? null : GetUserById((int)r["Sender"]);

                TransferList.Add(new Transfer(Title, Description, Amount, Recipient, Date, Type, Sender));
            }

            return TransferList;
        }
        }
\end{lstlisting}
=======
\begin{lstlisting}[caption={Statisk klasse, der forbinder til den relationelle database SQLite},label={lst:sqlite}]
public static class db
{
	private const string dbFileName = "test.sqlite";
	private static SQLiteConnection conn;

	public static void OpenDB()
	{
		conn = new SQLiteConnection("Data Source=" + dbFileName + ";Version=3;");
		conn.Open();
	}

	public static void CloseDB()
	{
	conn.Close();
	}


	public static void Store(Transfer transfer)
	{
		int ChildIDInDB = GetIDOfChild(transfer.Recipient);
		string ChildID = ((ChildIDInDB == 0) ? "null" : ChildIDInDB.ToString());

		string query = "INSERT INTO Transfers (Title, Description, Amount, Recipient, Date, Type, Sender) VALUES ('" +
		transfer.Title + "', '" +
		transfer.Description + "', '" +
		transfer.Amount.ToString(CultureInfo.GetCultureInfo("en-GB")) + "', '" +
		ChildID + "', '" +
		SQLiteConvert.ToUnixEpoch((DateTime)transfer.TransferDate) + "', '" +
		//DateTimeToUnixTimeStamp((DateTime)transfer.TransferDate) + "', '" +
		(int)transfer.Type + "', '" +
		null" + "')"; //GetIDOfUser(transfer.Sender) + "', '" +   //TODO: implement

		SQLiteCommand command = new SQLiteCommand(query, conn);
		command.ExecuteNonQuery();
	}


	public static Collection<Transfer> GetTransfersForChild(Child child)
	{
		string query = "SELECT * FROM Transfers WHERE " +
						"Recipient IN (SELECT ID FROM Childs WHERE " +
						"FirstName='" + child.FirstName + "'" +
						")";

		SQLiteCommand command = new SQLiteCommand(query, conn);
		SQLiteDataReader r = command.ExecuteReader();

		Collection<Transfer> TransferList = new Collection<Transfer>();

		while (r.Read())
		{
			int ID = r.GetInt32(r.GetOrdinal("ID"));
			string Title = r.GetString(r.GetOrdinal("Title"));
			string Description = r.GetString(r.GetOrdinal("Description"));
			decimal Amount = r.GetDecimal(r.GetOrdinal("Amount"));
			Child Recipient = child;
			DateTime Date = SQLiteConvert.ToDateTime(((long)r["Date"]).ToString(), SQLiteDateFormats.UnixEpoch, DateTimeKind.Local);
			ActivityType Type = (ActivityType)(long)r["Type"];
			User Sender = null; //TODO: implement   ((int)r["Sender"] == null) ? null : GetUserById((int)r["Sender"]);

			TransferList.Add(new Transfer(Title, Description, Amount, Recipient, Date, Type, Sender));
		}

		return TransferList;
	}
}
\end{lstlisting}
>>>>>>> a3bc11d472c8f56ad18f08cf31e3e7254c614162
